<!doctype html><html lang=zh dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>ROS 学习笔记1 | Mens et Manus</title>
<meta name=keywords content="ROS">
<meta name=description content="个人学习过程中的笔记，如有不足敬请指正。
 1. ROS 的基本概念 ROS (机器人操作系统) 简单来说就是提供了通讯框架，工具和现成功能的平台，我们最主要用的是通讯功能和工具套件。通讯功能主要包括同步通讯 (Service) 和异步通讯 (Topic)；工具包括 rviz, Gazebo 等。ROS 的分布式框架设计方便智能驾驶和机器人这种多机通讯，数据流分散的场合。
1.1 计算图级 其实就是 ROS 通讯的拓扑网络，是一种点对点的通讯形式。
1. Node 节点，进程，或者说功能单元，是代码模块的最小单位，或者说是最小的单个可执行文件。
ROS 的通讯其实就是节点和节点之间 (不一定直接)的通信。
一个节点既可以实现订阅，也可以实现发布，也能同时实现。
2. Master 主人？ 节点管理器，所有的节点都要找它进行注册才能被其他节点发现。因此要先启动节点管理器 (roscore)再启动节点 (rosrun)。
3. Message 消息，节点之间通讯的内容或媒介，可以自定义格式，就和 C 语言里的结构体一样，只不过 Message 更像是具体的对象，抽象的 *.msg 定义在对应 Topic 的文件夹中，或是单独作为一个程序包并被其他程序包所包括。
4. Topic 话题，或者叫主题，可以看成是一个频道，或者说是一个广场，单个或多个节点可以向一个话题发送消息，单个或多个节点也可以去订阅这个话题来获取消息。因此，话题的存在实现了消息发布者和消息订阅者之间的解耦，两者无需直接通信，无需知道对方的存在。
一个话题对应一种格式类型的 Message。
Topic 的内容在代码层面是字符串。
5. Service 服务，相对于话题的通讯模式是像 UDP 的广播式，它更像是TCP，是一端到另一端的直接通讯，并针对一次请求给予一次回应。因此没有频繁的消息传递，也就没有高系统资源占用。
Service通信是一对一通信，信息流是双向的，而且客户端与服务端之间的执行是同步的 (有一定顺序的)。
6. Bag 包 (为了区别下文中的程序包package一般口头叫它rosbag)，用于保存并回放 ROS 运行中所有消息数据的特殊格式，在 debug 和数据后处理阶段非常有用。
 回放 bag 时，Master 会创建一个临时节点来发送 bag 中记录的数据，其他所有话题直接订阅这个临时节点，消息是不经过我们自定义的节点的。因此，使用 bag 录制的数据来验证后修改的代码是不可行的。">
<meta name=author content="Me">
<link rel=canonical href=https://loganchow.github.io/posts/ros%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.5e2b4101351c21e906f398ae96901791830f58d430f96f2659dab7eaef7b3cb7.css integrity="sha256-XitBATUcIekG85iulpAXkYMPWNQw+W8mWdq36u97PLc=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://loganchow.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://loganchow.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://loganchow.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://loganchow.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://loganchow.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.89.4">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-138915624-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="ROS 学习笔记1">
<meta property="og:description" content="个人学习过程中的笔记，如有不足敬请指正。
 1. ROS 的基本概念 ROS (机器人操作系统) 简单来说就是提供了通讯框架，工具和现成功能的平台，我们最主要用的是通讯功能和工具套件。通讯功能主要包括同步通讯 (Service) 和异步通讯 (Topic)；工具包括 rviz, Gazebo 等。ROS 的分布式框架设计方便智能驾驶和机器人这种多机通讯，数据流分散的场合。
1.1 计算图级 其实就是 ROS 通讯的拓扑网络，是一种点对点的通讯形式。
1. Node 节点，进程，或者说功能单元，是代码模块的最小单位，或者说是最小的单个可执行文件。
ROS 的通讯其实就是节点和节点之间 (不一定直接)的通信。
一个节点既可以实现订阅，也可以实现发布，也能同时实现。
2. Master 主人？ 节点管理器，所有的节点都要找它进行注册才能被其他节点发现。因此要先启动节点管理器 (roscore)再启动节点 (rosrun)。
3. Message 消息，节点之间通讯的内容或媒介，可以自定义格式，就和 C 语言里的结构体一样，只不过 Message 更像是具体的对象，抽象的 *.msg 定义在对应 Topic 的文件夹中，或是单独作为一个程序包并被其他程序包所包括。
4. Topic 话题，或者叫主题，可以看成是一个频道，或者说是一个广场，单个或多个节点可以向一个话题发送消息，单个或多个节点也可以去订阅这个话题来获取消息。因此，话题的存在实现了消息发布者和消息订阅者之间的解耦，两者无需直接通信，无需知道对方的存在。
一个话题对应一种格式类型的 Message。
Topic 的内容在代码层面是字符串。
5. Service 服务，相对于话题的通讯模式是像 UDP 的广播式，它更像是TCP，是一端到另一端的直接通讯，并针对一次请求给予一次回应。因此没有频繁的消息传递，也就没有高系统资源占用。
Service通信是一对一通信，信息流是双向的，而且客户端与服务端之间的执行是同步的 (有一定顺序的)。
6. Bag 包 (为了区别下文中的程序包package一般口头叫它rosbag)，用于保存并回放 ROS 运行中所有消息数据的特殊格式，在 debug 和数据后处理阶段非常有用。
 回放 bag 时，Master 会创建一个临时节点来发送 bag 中记录的数据，其他所有话题直接订阅这个临时节点，消息是不经过我们自定义的节点的。因此，使用 bag 录制的数据来验证后修改的代码是不可行的。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://loganchow.github.io/posts/ros%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2020-06-18T22:24:42+08:00">
<meta property="article:modified_time" content="2020-06-18T22:24:42+08:00"><meta property="og:site_name" content="Mens et Manus">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="ROS 学习笔记1">
<meta name=twitter:description content="个人学习过程中的笔记，如有不足敬请指正。
 1. ROS 的基本概念 ROS (机器人操作系统) 简单来说就是提供了通讯框架，工具和现成功能的平台，我们最主要用的是通讯功能和工具套件。通讯功能主要包括同步通讯 (Service) 和异步通讯 (Topic)；工具包括 rviz, Gazebo 等。ROS 的分布式框架设计方便智能驾驶和机器人这种多机通讯，数据流分散的场合。
1.1 计算图级 其实就是 ROS 通讯的拓扑网络，是一种点对点的通讯形式。
1. Node 节点，进程，或者说功能单元，是代码模块的最小单位，或者说是最小的单个可执行文件。
ROS 的通讯其实就是节点和节点之间 (不一定直接)的通信。
一个节点既可以实现订阅，也可以实现发布，也能同时实现。
2. Master 主人？ 节点管理器，所有的节点都要找它进行注册才能被其他节点发现。因此要先启动节点管理器 (roscore)再启动节点 (rosrun)。
3. Message 消息，节点之间通讯的内容或媒介，可以自定义格式，就和 C 语言里的结构体一样，只不过 Message 更像是具体的对象，抽象的 *.msg 定义在对应 Topic 的文件夹中，或是单独作为一个程序包并被其他程序包所包括。
4. Topic 话题，或者叫主题，可以看成是一个频道，或者说是一个广场，单个或多个节点可以向一个话题发送消息，单个或多个节点也可以去订阅这个话题来获取消息。因此，话题的存在实现了消息发布者和消息订阅者之间的解耦，两者无需直接通信，无需知道对方的存在。
一个话题对应一种格式类型的 Message。
Topic 的内容在代码层面是字符串。
5. Service 服务，相对于话题的通讯模式是像 UDP 的广播式，它更像是TCP，是一端到另一端的直接通讯，并针对一次请求给予一次回应。因此没有频繁的消息传递，也就没有高系统资源占用。
Service通信是一对一通信，信息流是双向的，而且客户端与服务端之间的执行是同步的 (有一定顺序的)。
6. Bag 包 (为了区别下文中的程序包package一般口头叫它rosbag)，用于保存并回放 ROS 运行中所有消息数据的特殊格式，在 debug 和数据后处理阶段非常有用。
 回放 bag 时，Master 会创建一个临时节点来发送 bag 中记录的数据，其他所有话题直接订阅这个临时节点，消息是不经过我们自定义的节点的。因此，使用 bag 录制的数据来验证后修改的代码是不可行的。">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://loganchow.github.io/posts/"},{"@type":"ListItem","position":2,"name":"ROS 学习笔记1","item":"https://loganchow.github.io/posts/ros%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ROS 学习笔记1","name":"ROS 学习笔记1","description":"个人学习过程中的笔记，如有不足敬请指正。\n 1. ROS 的基本概念 ROS (机器人操作系统) 简单来说就是提供了通讯框架，工具和现成功能的平台，我们最主要用的是通讯功能和工具套件。通讯功能主要包括同步通讯 (Service) 和异步通讯 (Topic)；工具包括 rviz, Gazebo 等。ROS 的分布式框架设计方便智能驾驶和机器人这种多机通讯，数据流分散的场合。\n1.1 计算图级 其实就是 ROS 通讯的拓扑网络，是一种点对点的通讯形式。\n1. Node 节点，进程，或者说功能单元，是代码模块的最小单位，或者说是最小的单个可执行文件。\nROS 的通讯其实就是节点和节点之间 (不一定直接)的通信。\n一个节点既可以实现订阅，也可以实现发布，也能同时实现。\n2. Master 主人？ 节点管理器，所有的节点都要找它进行注册才能被其他节点发现。因此要先启动节点管理器 (roscore)再启动节点 (rosrun)。\n3. Message 消息，节点之间通讯的内容或媒介，可以自定义格式，就和 C 语言里的结构体一样，只不过 Message 更像是具体的对象，抽象的 *.msg 定义在对应 Topic 的文件夹中，或是单独作为一个程序包并被其他程序包所包括。\n4. Topic 话题，或者叫主题，可以看成是一个频道，或者说是一个广场，单个或多个节点可以向一个话题发送消息，单个或多个节点也可以去订阅这个话题来获取消息。因此，话题的存在实现了消息发布者和消息订阅者之间的解耦，两者无需直接通信，无需知道对方的存在。\n一个话题对应一种格式类型的 Message。\nTopic 的内容在代码层面是字符串。\n5. Service 服务，相对于话题的通讯模式是像 UDP 的广播式，它更像是TCP，是一端到另一端的直接通讯，并针对一次请求给予一次回应。因此没有频繁的消息传递，也就没有高系统资源占用。\nService通信是一对一通信，信息流是双向的，而且客户端与服务端之间的执行是同步的 (有一定顺序的)。\n6. Bag 包 (为了区别下文中的程序包package一般口头叫它rosbag)，用于保存并回放 ROS 运行中所有消息数据的特殊格式，在 debug 和数据后处理阶段非常有用。\n 回放 bag 时，Master 会创建一个临时节点来发送 bag 中记录的数据，其他所有话题直接订阅这个临时节点，消息是不经过我们自定义的节点的。因此，使用 bag 录制的数据来验证后修改的代码是不可行的。","keywords":["ROS"],"articleBody":" 个人学习过程中的笔记，如有不足敬请指正。\n 1. ROS 的基本概念 ROS (机器人操作系统) 简单来说就是提供了通讯框架，工具和现成功能的平台，我们最主要用的是通讯功能和工具套件。通讯功能主要包括同步通讯 (Service) 和异步通讯 (Topic)；工具包括 rviz, Gazebo 等。ROS 的分布式框架设计方便智能驾驶和机器人这种多机通讯，数据流分散的场合。\n1.1 计算图级 其实就是 ROS 通讯的拓扑网络，是一种点对点的通讯形式。\n1. Node 节点，进程，或者说功能单元，是代码模块的最小单位，或者说是最小的单个可执行文件。\nROS 的通讯其实就是节点和节点之间 (不一定直接)的通信。\n一个节点既可以实现订阅，也可以实现发布，也能同时实现。\n2. Master 主人？ 节点管理器，所有的节点都要找它进行注册才能被其他节点发现。因此要先启动节点管理器 (roscore)再启动节点 (rosrun)。\n3. Message 消息，节点之间通讯的内容或媒介，可以自定义格式，就和 C 语言里的结构体一样，只不过 Message 更像是具体的对象，抽象的 *.msg 定义在对应 Topic 的文件夹中，或是单独作为一个程序包并被其他程序包所包括。\n4. Topic 话题，或者叫主题，可以看成是一个频道，或者说是一个广场，单个或多个节点可以向一个话题发送消息，单个或多个节点也可以去订阅这个话题来获取消息。因此，话题的存在实现了消息发布者和消息订阅者之间的解耦，两者无需直接通信，无需知道对方的存在。\n一个话题对应一种格式类型的 Message。\nTopic 的内容在代码层面是字符串。\n5. Service 服务，相对于话题的通讯模式是像 UDP 的广播式，它更像是TCP，是一端到另一端的直接通讯，并针对一次请求给予一次回应。因此没有频繁的消息传递，也就没有高系统资源占用。\nService通信是一对一通信，信息流是双向的，而且客户端与服务端之间的执行是同步的 (有一定顺序的)。\n6. Bag 包 (为了区别下文中的程序包package一般口头叫它rosbag)，用于保存并回放 ROS 运行中所有消息数据的特殊格式，在 debug 和数据后处理阶段非常有用。\n 回放 bag 时，Master 会创建一个临时节点来发送 bag 中记录的数据，其他所有话题直接订阅这个临时节点，消息是不经过我们自定义的节点的。因此，使用 bag 录制的数据来验证后修改的代码是不可行的。\n 1.2 文件系统 直观的说，就是我们写的代码和其他附加文件的组织结构。由于 ROS 是基于 CMake 编译系统组织的，因此 ROS 的文件系统就是 catkin workspace 的组织形式。\n1. Package 功能包，ROS 的基本组织形式，CMake 的基本编译单元，用于组织 ROS 中不同的功能模块。一个功能包可以包含多个可执行文件 (节点)。\nROS 的实现就是通过包的形式把各种节点、依赖库、驱动、配置文件和数据库联系起来 (涉及编译与链接原理)。\n2. Stack 堆，单个或多个包的集合，一般实现一个完整功能，与发行有关，不常用。\n3. Workspace 工作空间，组织一个完整 ROS 项目的总文件夹，一个 ROS workspace 就是一个 catkin workspace。\n2. ROS 的基本开发步骤 2.1 初始化工作空间 创建一个 catkin 工作空间并初始化：\nmkdir catkin_ws cd catkin_ws catkin_make 一个 catkin workspace 中的文件夹主要包括：\n src ：代码源文件 build ：中间文件 devel ：目标文件、头文件与链接库  2.2 编写代码 在 src 文件夹里创建所需的 package：\ncd src # catkin_create_pkg   catkin_create_pkg package_name rospy std_msgs 一个功能包中的主要文件包括：\n CMakeLists.txt (必须): 规定本功能包的编译规则 package.xml (必须): 描述文件，定义 package 的属性信息，如包名、版本、作者等。一般只需要改和这两个字段。 scripts: 存放 shell 或 python 脚本 include: 源代码的头文件 src: cpp 源代码 msg: 自定义消息格式，*.msg srv: 自定义服务，*.srv action：自定义动作，*.action config: 参数、设置文件等，如*.yaml launch: 启动文件 *.launch，配合 roslaunch 命令可以一次运行多个节点  2.3 编译工作空间 编译完整的工作空间，包括内部所有功能包\ncd ~/catkin_ws catkin_make CMake编译系统的流程包括：\n 首先在工作空间 catkin_ws/src/ 下递归的查找其中每一个ROS package CMake 编译系统依据 CMakeLists.txt 文件，生成makefiles(放在catkin_ws/build/中) 然后make刚刚生成的makefiles等文件，编译链接生成可执行文件（放在 catkin_ws/devel 中）  2.4 为当前 Terminal 刷新环境变量 在要执行 ROS 节点的终端中执行：\nsource ~/catkin_ws/devel/setup.bash 将新编译的相关环境变量加载到当前终端窗口。\n2.5 检查环境变量（可选） 参考资料  ROS 培训教程 古月居 ROS Wiki ROS Tutorials 创客  ","wordCount":"219","inLanguage":"zh","datePublished":"2020-06-18T22:24:42+08:00","dateModified":"2020-06-18T22:24:42+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://loganchow.github.io/posts/ros%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"},"publisher":{"@type":"Organization","name":"Mens et Manus","logo":{"@type":"ImageObject","url":"https://loganchow.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://loganchow.github.io/ accesskey=h title="Logan's Space (Alt + H)">Logan's Space</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://loganchow.github.io/archives title=归档>
<span>归档</span>
</a>
</li>
<li>
<a href=https://loganchow.github.io/categories/ title=分类>
<span>分类</span>
</a>
</li>
<li>
<a href=https://loganchow.github.io/search/ title=搜索>
<span>搜索</span>
</a>
</li>
<li>
<a href=https://loganchow.github.io/tags/ title=标签>
<span>标签</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://loganchow.github.io/>主页</a>&nbsp;»&nbsp;<a href=https://loganchow.github.io/posts/>Posts</a></div>
<h1 class=post-title>
ROS 学习笔记1
</h1>
<div class=post-meta>June 18, 2020&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/loganchow/loganchow.github.io/content/posts/ROS%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b01.md rel="noopener noreferrer" target=_blank>Suggest Changes</a>
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>目录</span>
</summary>
<div class=inner><ul>
<li>
<a href=#1-ros-%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5 aria-label="1. ROS 的基本概念">1. ROS 的基本概念</a><ul>
<li>
<a href=#11-%e8%ae%a1%e7%ae%97%e5%9b%be%e7%ba%a7 aria-label="1.1 计算图级">1.1 计算图级</a><ul>
<li>
<a href=#1-node aria-label="1. Node">1. Node</a></li>
<li>
<a href=#2-master aria-label="2. Master">2. Master</a></li>
<li>
<a href=#3-message aria-label="3. Message">3. Message</a></li>
<li>
<a href=#4-topic aria-label="4. Topic">4. Topic</a></li>
<li>
<a href=#5-service aria-label="5. Service">5. Service</a></li>
<li>
<a href=#6-bag aria-label="6. Bag">6. Bag</a></li></ul>
</li>
<li>
<a href=#12-%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f aria-label="1.2 文件系统">1.2 文件系统</a><ul>
<li>
<a href=#1-package aria-label="1. Package">1. Package</a></li>
<li>
<a href=#2-stack aria-label="2. Stack">2. Stack</a></li>
<li>
<a href=#3-workspace aria-label="3. Workspace">3. Workspace</a></li></ul>
</li></ul>
</li>
<li>
<a href=#2-ros-%e7%9a%84%e5%9f%ba%e6%9c%ac%e5%bc%80%e5%8f%91%e6%ad%a5%e9%aa%a4 aria-label="2. ROS 的基本开发步骤">2. ROS 的基本开发步骤</a><ul>
<li>
<a href=#21-%e5%88%9d%e5%a7%8b%e5%8c%96%e5%b7%a5%e4%bd%9c%e7%a9%ba%e9%97%b4 aria-label="2.1 初始化工作空间">2.1 初始化工作空间</a></li>
<li>
<a href=#22-%e7%bc%96%e5%86%99%e4%bb%a3%e7%a0%81 aria-label="2.2 编写代码">2.2 编写代码</a></li>
<li>
<a href=#23-%e7%bc%96%e8%af%91%e5%b7%a5%e4%bd%9c%e7%a9%ba%e9%97%b4 aria-label="2.3 编译工作空间">2.3 编译工作空间</a></li>
<li>
<a href=#24-%e4%b8%ba%e5%bd%93%e5%89%8d-terminal-%e5%88%b7%e6%96%b0%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f aria-label="2.4 为当前 Terminal 刷新环境变量">2.4 为当前 Terminal 刷新环境变量</a></li>
<li>
<a href=#25-%e6%a3%80%e6%9f%a5%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f%e5%8f%af%e9%80%89 aria-label="2.5 检查环境变量（可选）">2.5 检查环境变量（可选）</a></li></ul>
</li>
<li>
<a href=#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99 aria-label=参考资料>参考资料</a>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><blockquote>
<p>个人学习过程中的笔记，如有不足敬请指正。</p>
</blockquote>
<h1 id=1-ros-的基本概念>1. ROS 的基本概念<a hidden class=anchor aria-hidden=true href=#1-ros-的基本概念>#</a></h1>
<p>ROS (机器人操作系统) 简单来说就是提供了通讯框架，工具和现成功能的平台，我们最主要用的是通讯功能和工具套件。通讯功能主要包括同步通讯 (Service) 和异步通讯 (Topic)；工具包括 rviz, Gazebo 等。ROS 的分布式框架设计方便智能驾驶和机器人这种多机通讯，数据流分散的场合。</p>
<h2 id=11-计算图级>1.1 计算图级<a hidden class=anchor aria-hidden=true href=#11-计算图级>#</a></h2>
<p>其实就是 ROS 通讯的拓扑网络，是一种点对点的通讯形式。</p>
<h3 id=1-node>1. Node<a hidden class=anchor aria-hidden=true href=#1-node>#</a></h3>
<p>节点，进程，或者说功能单元，是代码模块的最小单位，或者说是最小的单个可执行文件。</p>
<p>ROS 的通讯其实就是节点和节点之间 (不一定直接)的通信。</p>
<p>一个节点既可以实现订阅，也可以实现发布，也能同时实现。</p>
<h3 id=2-master>2. Master<a hidden class=anchor aria-hidden=true href=#2-master>#</a></h3>
<p><del>主人？</del> 节点管理器，所有的节点都要找它进行注册才能被其他节点发现。因此要先启动节点管理器 (<code>roscore</code>)再启动节点 (<code>rosrun</code>)。</p>
<h3 id=3-message>3. Message<a hidden class=anchor aria-hidden=true href=#3-message>#</a></h3>
<p>消息，节点之间通讯的内容或媒介，可以自定义格式，就和 C 语言里的结构体一样，只不过 Message 更像是具体的对象，抽象的 <code>*.msg</code> 定义在对应 Topic 的文件夹中，或是单独作为一个程序包并被其他程序包所包括。</p>
<h3 id=4-topic>4. Topic<a hidden class=anchor aria-hidden=true href=#4-topic>#</a></h3>
<p>话题，或者叫主题，可以看成是一个频道，或者说是一个广场，单个或多个节点可以向一个话题发送消息，单个或多个节点也可以去订阅这个话题来获取消息。因此，话题的存在实现了消息发布者和消息订阅者之间的解耦，两者无需直接通信，无需知道对方的存在。</p>
<p>一个话题对应一种格式类型的 Message。</p>
<p>Topic 的内容在代码层面是字符串。</p>
<h3 id=5-service>5. Service<a hidden class=anchor aria-hidden=true href=#5-service>#</a></h3>
<p>服务，相对于话题的通讯模式是像 UDP 的广播式，它更像是TCP，是一端到另一端的直接通讯，并针对一次请求给予一次回应。因此没有频繁的消息传递，也就没有高系统资源占用。</p>
<p>Service通信是一对一通信，信息流是双向的，而且客户端与服务端之间的执行是同步的 (有一定顺序的)。</p>
<h3 id=6-bag>6. Bag<a hidden class=anchor aria-hidden=true href=#6-bag>#</a></h3>
<p>包 (为了区别下文中的程序包<code>package</code>一般口头叫它<code>rosbag</code>)，用于保存并回放 ROS 运行中所有消息数据的特殊格式，在 debug 和数据后处理阶段非常有用。</p>
<blockquote>
<p>回放 bag 时，Master 会创建一个临时节点来发送 bag 中记录的数据，其他所有话题直接订阅这个临时节点，消息是不经过我们自定义的节点的。因此，使用 bag 录制的数据来验证后修改的代码是<strong>不可行</strong>的。</p>
</blockquote>
<h2 id=12-文件系统>1.2 文件系统<a hidden class=anchor aria-hidden=true href=#12-文件系统>#</a></h2>
<p>直观的说，就是我们写的代码和其他附加文件的组织结构。由于 ROS 是基于 CMake 编译系统组织的，因此 ROS 的文件系统就是 catkin workspace 的组织形式。</p>
<h3 id=1-package>1. Package<a hidden class=anchor aria-hidden=true href=#1-package>#</a></h3>
<p>功能包，ROS 的基本组织形式，CMake 的基本编译单元，用于组织 ROS 中不同的功能模块。一个功能包可以包含多个可执行文件 (节点)。</p>
<p>ROS 的实现就是通过包的形式把各种节点、依赖库、驱动、配置文件和数据库联系起来 (涉及编译与链接原理)。</p>
<h3 id=2-stack>2. Stack<a hidden class=anchor aria-hidden=true href=#2-stack>#</a></h3>
<p>堆，单个或多个包的集合，一般实现一个完整功能，与发行有关，不常用。</p>
<h3 id=3-workspace>3. Workspace<a hidden class=anchor aria-hidden=true href=#3-workspace>#</a></h3>
<p>工作空间，组织一个完整 ROS 项目的总文件夹，一个 ROS workspace 就是一个 catkin workspace。</p>
<h1 id=2-ros-的基本开发步骤>2. ROS 的基本开发步骤<a hidden class=anchor aria-hidden=true href=#2-ros-的基本开发步骤>#</a></h1>
<h2 id=21-初始化工作空间>2.1 初始化工作空间<a hidden class=anchor aria-hidden=true href=#21-初始化工作空间>#</a></h2>
<p>创建一个 catkin 工作空间并初始化：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>mkdir catkin_ws
cd catkin_ws
catkin_make
</code></pre></div><p>一个 catkin workspace 中的文件夹主要包括：</p>
<ul>
<li><code>src</code> ：代码源文件</li>
<li><code>build</code> ：中间文件</li>
<li><code>devel</code> ：目标文件、头文件与链接库</li>
</ul>
<h2 id=22-编写代码>2.2 编写代码<a hidden class=anchor aria-hidden=true href=#22-编写代码>#</a></h2>
<p>在 <code>src</code> 文件夹里创建所需的 <code>package</code>：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>cd src
<span style=color:#75715e># catkin_create_pkg &lt;new_package_name&gt; &lt;package_deps&gt;</span>
catkin_create_pkg package_name rospy std_msgs
</code></pre></div><p>一个功能包中的主要文件包括：</p>
<ul>
<li><code>CMakeLists.txt</code> (必须): 规定本功能包的编译规则</li>
<li><code>package.xml</code> (必须): 描述文件，定义 package 的属性信息，如包名、版本、作者等。一般只需要改<code>&lt;build_depend></code>和<code>&lt;run_depend></code>这两个字段。</li>
<li><code>scripts</code>: 存放 shell 或 python 脚本</li>
<li><code>include</code>: 源代码的头文件</li>
<li><code>src</code>: cpp 源代码</li>
<li><code>msg</code>: 自定义消息格式，*.msg</li>
<li><code>srv</code>: 自定义服务，*.srv</li>
<li><code>action</code>：自定义动作，*.action</li>
<li><code>config</code>: 参数、设置文件等，如*.yaml</li>
<li><code>launch</code>: 启动文件 <code>*.launch</code>，配合 <code>roslaunch</code> 命令可以一次运行多个节点</li>
</ul>
<h2 id=23-编译工作空间>2.3 编译工作空间<a hidden class=anchor aria-hidden=true href=#23-编译工作空间>#</a></h2>
<p>编译完整的工作空间，包括内部所有功能包</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>cd ~/catkin_ws
catkin_make
</code></pre></div><p>CMake编译系统的流程包括：</p>
<ol>
<li>首先在工作空间 <code>catkin_ws/src/</code> 下递归的查找其中每一个ROS package</li>
<li>CMake 编译系统依据 <code>CMakeLists.txt</code> 文件，生成makefiles(放在catkin_ws/build/中)</li>
<li>然后make刚刚生成的makefiles等文件，编译链接生成可执行文件（放在 <code>catkin_ws/devel</code> 中）</li>
</ol>
<h2 id=24-为当前-terminal-刷新环境变量>2.4 为当前 Terminal 刷新环境变量<a hidden class=anchor aria-hidden=true href=#24-为当前-terminal-刷新环境变量>#</a></h2>
<p>在要执行 ROS 节点的终端中执行：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>source ~/catkin_ws/devel/setup.bash
</code></pre></div><p>将新编译的相关环境变量加载到当前终端窗口。</p>
<h2 id=25-检查环境变量可选>2.5 检查环境变量（可选）<a hidden class=anchor aria-hidden=true href=#25-检查环境变量可选>#</a></h2>
<h1 id=参考资料>参考资料<a hidden class=anchor aria-hidden=true href=#参考资料>#</a></h1>
<ol>
<li><a href=https://tr-ros-tutorial.readthedocs.io/zh_CN/latest/index.html>ROS 培训教程</a></li>
<li><a href=https://www.guyuehome.com/Blog/index/category/11/p/1>古月居</a></li>
<li><a href=http://wiki.ros.org/>ROS Wiki</a></li>
<li><a href=http://wiki.ros.org/ROS/Tutorials>ROS Tutorials</a></li>
<li><a href=https://www.ncnynl.com/>创客</a></li>
</ol>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://loganchow.github.io/tags/ros/>ROS</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://loganchow.github.io/posts/%E4%B8%9C%E5%A4%A719%E5%BC%80%E5%AD%A6%E5%BC%8F/>
<span class=title>« 上一页</span>
<br>
<span>【转】2019年东京大学入学典礼 上野千鹤子教授演讲全文</span>
</a>
<a class=next href=https://loganchow.github.io/posts/nvdia_chrome_gpu_cache/>
<span class=title>下一页 »</span>
<br>
<span>NVIDIA 驱动更新后 Chrome 黑屏故障排除记录</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=https://loganchow.github.io/>Mens et Manus</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>