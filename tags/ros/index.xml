<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>ROS on Mens et Manus</title>
    <link>https://loganchow.github.io/tags/ros/</link>
    <description>Recent content in ROS on Mens et Manus</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 18 Jun 2020 22:24:42 +0800</lastBuildDate><atom:link href="https://loganchow.github.io/tags/ros/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ROS 学习笔记1</title>
      <link>https://loganchow.github.io/posts/ros%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</link>
      <pubDate>Thu, 18 Jun 2020 22:24:42 +0800</pubDate>
      
      <guid>https://loganchow.github.io/posts/ros%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</guid>
      <description>个人学习过程中的笔记，如有不足敬请指正。
 1. ROS 的基本概念 ROS (机器人操作系统) 简单来说就是提供了通讯框架，工具和现成的功能的平台，我们最主要用的是通讯功能和工具套件。通讯功能主要包括同步 RPC 通讯 (Service)和异步通讯 (Topic)；工具包括 rviz, Gazebo 等。ROS 的分布式框架设计方便智能驾驶和机器人这种多机通讯，数据流分散的场合。
1.1 计算图级 其实就是 ROS 通讯的拓扑网络，是一种点对点的通讯形式。
1. Node 节点，进程，或者说功能单元，是代码模块的最小单位，或者说是最小的单个可执行文件。
ROS 的通讯其实就是节点和节点之间 (不一定直接)的通信。
一个节点既可以实现订阅，也可以实现发布，也能同时实现。
2. Master 主人？ 节点管理器，所有的节点都要找它进行注册才能被其他节点发现。因此要先启动节点管理器 (roscore)再启动节点 (rosrun)。
3. Message 消息，节点之间通讯的内容或媒介，可以自定义格式，就和 C 语言里的结构体一样，只不过 Message 更像是具体的对象，抽象的 *.msg 定义在对应 Topic 的文件夹中，或是单独作为一个程序包并被其他程序包所包括。
4. Topic 话题，或者叫主题，可以看成是一个频道，或者说是一个广场，单个或多个节点可以向一个话题发送消息，单个或多个节点也可以去订阅这个话题来获取消息。因此，话题的存在实现了消息发布者和消息订阅者之间的解耦，两者无需直接通信，无需知道对方的存在。
一个话题对应一种格式类型的 Message。
Topic 在代码层面是字符串。
5. Service 服务，相对于话题的通讯模式是广播式的，像UDP，它更像是TCP，是一端到另一端的直接通讯，并针对一次请求给予一次回应。因此没有频繁的消息传递，没有高系统资源占用。
Service通信是一对一通信，信息流是双向的，而且客户端与服务端之间的执行是同步的 (有一定顺序的)。
6. Bag 包 (为了区别下文中的程序包package一般叫它rosbag)，用于保存并回放 ROS 运行中所有消息数据的特殊格式，在 debug 和数据后处理阶段非常有用。
1.2 文件系统 直观的说，就是我们写的代码和其他附加文件的组织结构。由于 ROS 是基于 CMake 编译系统组织的，因此 ROS 的文件系统就是 catkin workspace 的组织形式。</description>
    </item>
    
  </channel>
</rss>
